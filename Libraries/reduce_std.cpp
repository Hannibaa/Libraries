#include <iostream>
#include <algorithm>
#include <numbers>
#include <array>
#include <sstream>

#include "MyLib/Console_Library/escape_code.h"
#include "MyLib/container_utility.h"
#include "MyLib/stringfunctionhelper.h"
#include "MyLib/bit_utility.h"


union uIpv4 {
	int   ip;
	uchar _1;
	uchar _2;
	uchar _3;
	uchar _4;
};

struct IP {
	std::string    sIp4;
	uIpv4          ipv4;

	IP()
		:ipv4{ .ip{0} },
		 sIp4{"0.0.0.0"}
	{}

	IP(int ip)
		:ipv4{ip},
		 sIp4{make_ipv4String(ip)}
	{}

	// make adress string from int type
	std::string make_ipv4String(int ip) {
		std::stringstream ss;

		ss << (int)_CHAR_HH_INT(ip) << "."
			<< (int)_CHAR_HL_INT(ip) << "."
			<< (int)_CHAR_LH_INT(ip) << "."
			<< (int)_CHAR_LL_INT(ip);

		return ss.str();
	}

	// check if string in is ip adress 
	bool is_ipadress4() {
		// the string should be of type uchar.uchar.uchar.uchar

		// should have 3 point to separate adress


		return true;
	}
};


int get_random_ipv4() {

	return{};
}

std::string make_ipv4String(int ip) {
	std::stringstream ss;

	ss <<  (int)_CHAR_HH_INT(ip) << "."
		<< (int)_CHAR_HL_INT(ip) << "."
		<< (int)_CHAR_LH_INT(ip) << "."
		<< (int)_CHAR_LL_INT(ip) ;

	return ss.str();
}

std::string make_ipv4String(byte c1, byte c2, byte c3, byte c4) {
	std::stringstream ss;
	ss << (int)c1 << "."
		<< (int)c2 << "."
		<< (int)c3 << "."
		<< (int)c4;

	return ss.str();
}

template<typename T, T _from, T _to>
std::string make_random_ipv4() {
	static_assert(std::is_integral_v<T>, "type should be integerat value ");
	static_assert();



}


// testing of get ipv4 :
//int main() {
//
//	Print_(color::Aqua, "testing get ipv4") << end_;
//
//	int ip1 = 0xf1f2f3f4;
//
//	print_ << "ip : " << make_ipv4String(ip1) << end_;
//	print_ << "ip : " << make_ipv4String(233, 200, 0xff, 0x0d) << end_;
//	
//	for (int k = 0; k < 10; ++k) {
//		print_ << "ip random : " 
//			<< make_ipv4String(byte(rand()), byte(rand()), byte(rand()), byte(rand())) << end_;
//		int ip2 = rand()*1000 ;
//		Print_(color::Green, "ip int random ") << make_ipv4String(ip2) << end_;
//	}
//
//
//	wait_;
//	return 0;
//}




int main()
{
	auto vec = cu::make_random_container<std::vector<float>>(0.f, 100.f, 10);

	Print_(color::Green, "Size of that vector is : ") << vec.size() << end_;
	wait_;
	cu::print_container(vec, "big vector : ");

	std::vector<float> vecFloat(100);
	std::generate(vecFloat.begin(), vecFloat.end(), 
		[]() {return float(rand() % 100)/float(rand()%13 + 1); });

	std::array<std::string, 10> arString;

	std::generate(arString.begin(), arString.end(),
		[]() {return Str::getRandomString("{@@@ @@@ @@@ --- }"); });

	// generate random ipv4 addresses :
	std::vector<std::string> vecString(10);
	std::generate(vecString.begin(), vecString.end(), 
		[]() {return make_ipv4String(rand()); });
    
	cu::print_container(vecFloat, "vector of float generated by generte function :");
	cu::print_container(arString, "array of string generated by function :");
	cu::print_container(vecString, "vector of ipv4 of addresses :");
	std::cin.get();
	return 0;
}